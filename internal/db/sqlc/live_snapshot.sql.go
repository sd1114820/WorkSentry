// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: live_snapshot.sql

package sqlc

import (
	"context"
	"database/sql"
)

const listLiveSnapshot = `-- name: ListLiveSnapshot :many
SELECT e.employee_code,
       e.name,
       d.name AS department_name,
       e.last_status,
       e.last_description,
       e.last_seen_at,
       CASE WHEN ws.active_start IS NULL THEN 0 ELSE 1 END AS is_working
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id
LEFT JOIN (
  SELECT employee_id, MAX(start_at) AS active_start
  FROM work_sessions
  WHERE end_at IS NULL
  GROUP BY employee_id
) ws ON ws.employee_id = e.id
WHERE e.enabled = 1
ORDER BY e.id DESC
`

type ListLiveSnapshotRow struct {
	EmployeeCode    string                  `json:"employee_code"`
	Name            string                  `json:"name"`
	DepartmentName  sql.NullString          `json:"department_name"`
	LastStatus      NullEmployeesLastStatus `json:"last_status"`
	LastDescription sql.NullString          `json:"last_description"`
	LastSeenAt      sql.NullTime            `json:"last_seen_at"`
	IsWorking       int64                   `json:"is_working"`
}

func (q *Queries) ListLiveSnapshot(ctx context.Context) ([]ListLiveSnapshotRow, error) {
	rows, err := q.db.QueryContext(ctx, listLiveSnapshot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLiveSnapshotRow
	for rows.Next() {
		var i ListLiveSnapshotRow
		if err := rows.Scan(
			&i.EmployeeCode,
			&i.Name,
			&i.DepartmentName,
			&i.LastStatus,
			&i.LastDescription,
			&i.LastSeenAt,
			&i.IsWorking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
