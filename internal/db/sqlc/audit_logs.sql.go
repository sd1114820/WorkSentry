// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createAuditLog = `-- name: CreateAuditLog :exec
INSERT INTO audit_logs (operator_id, action, target_type, target_id, detail)
VALUES (?, ?, ?, ?, ?)
`

type CreateAuditLogParams struct {
	OperatorID int64           `json:"operator_id"`
	Action     string          `json:"action"`
	TargetType string          `json:"target_type"`
	TargetID   sql.NullInt64   `json:"target_id"`
	Detail     json.RawMessage `json:"detail"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.ExecContext(ctx, createAuditLog,
		arg.OperatorID,
		arg.Action,
		arg.TargetType,
		arg.TargetID,
		arg.Detail,
	)
	return err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, operator_id, action, target_type, target_id, detail, created_at
FROM audit_logs
WHERE ( ? = '' OR DATE(created_at) = ? )
ORDER BY created_at DESC
LIMIT 200
`

type ListAuditLogsParams struct {
	Column1   interface{} `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogs, arg.Column1, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.OperatorID,
			&i.Action,
			&i.TargetType,
			&i.TargetID,
			&i.Detail,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
