// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: daily_stats.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addDailyStats = `-- name: AddDailyStats :exec
INSERT INTO daily_stats (
  stat_date,
  employee_id,
  work_seconds,
  normal_seconds,
  fish_seconds,
  idle_seconds,
  offline_seconds,
  attendance_seconds,
  effective_seconds
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
  work_seconds = GREATEST(0, work_seconds + VALUES(work_seconds)),
  normal_seconds = GREATEST(0, normal_seconds + VALUES(normal_seconds)),
  fish_seconds = GREATEST(0, fish_seconds + VALUES(fish_seconds)),
  idle_seconds = GREATEST(0, idle_seconds + VALUES(idle_seconds)),
  offline_seconds = GREATEST(0, offline_seconds + VALUES(offline_seconds)),
  attendance_seconds = GREATEST(0, attendance_seconds + VALUES(attendance_seconds)),
  effective_seconds = GREATEST(0, effective_seconds + VALUES(effective_seconds))
`

type AddDailyStatsParams struct {
	StatDate          time.Time `json:"stat_date"`
	EmployeeID        int64     `json:"employee_id"`
	WorkSeconds       int32     `json:"work_seconds"`
	NormalSeconds     int32     `json:"normal_seconds"`
	FishSeconds       int32     `json:"fish_seconds"`
	IdleSeconds       int32     `json:"idle_seconds"`
	OfflineSeconds    int32     `json:"offline_seconds"`
	AttendanceSeconds int32     `json:"attendance_seconds"`
	EffectiveSeconds  int32     `json:"effective_seconds"`
}

func (q *Queries) AddDailyStats(ctx context.Context, arg AddDailyStatsParams) error {
	_, err := q.db.ExecContext(ctx, addDailyStats,
		arg.StatDate,
		arg.EmployeeID,
		arg.WorkSeconds,
		arg.NormalSeconds,
		arg.FishSeconds,
		arg.IdleSeconds,
		arg.OfflineSeconds,
		arg.AttendanceSeconds,
		arg.EffectiveSeconds,
	)
	return err
}

const listDailyStatsByDate = `-- name: ListDailyStatsByDate :many
SELECT ds.stat_date,
       e.employee_code,
       e.name,
       d.name AS department_name,
       ds.work_seconds,
       ds.normal_seconds,
       ds.fish_seconds,
       ds.idle_seconds,
       ds.offline_seconds,
       ds.attendance_seconds,
       ds.effective_seconds
FROM daily_stats ds
JOIN employees e ON ds.employee_id = e.id
LEFT JOIN departments d ON e.department_id = d.id
WHERE ds.stat_date = ?
  AND (? = 0 OR e.department_id = ?)
ORDER BY ds.attendance_seconds DESC
`

type ListDailyStatsByDateParams struct {
	StatDate     time.Time     `json:"stat_date"`
	Column2      interface{}   `json:"column_2"`
	DepartmentID sql.NullInt64 `json:"department_id"`
}

type ListDailyStatsByDateRow struct {
	StatDate          time.Time      `json:"stat_date"`
	EmployeeCode      string         `json:"employee_code"`
	Name              string         `json:"name"`
	DepartmentName    sql.NullString `json:"department_name"`
	WorkSeconds       int32          `json:"work_seconds"`
	NormalSeconds     int32          `json:"normal_seconds"`
	FishSeconds       int32          `json:"fish_seconds"`
	IdleSeconds       int32          `json:"idle_seconds"`
	OfflineSeconds    int32          `json:"offline_seconds"`
	AttendanceSeconds int32          `json:"attendance_seconds"`
	EffectiveSeconds  int32          `json:"effective_seconds"`
}

func (q *Queries) ListDailyStatsByDate(ctx context.Context, arg ListDailyStatsByDateParams) ([]ListDailyStatsByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, listDailyStatsByDate, arg.StatDate, arg.Column2, arg.DepartmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDailyStatsByDateRow
	for rows.Next() {
		var i ListDailyStatsByDateRow
		if err := rows.Scan(
			&i.StatDate,
			&i.EmployeeCode,
			&i.Name,
			&i.DepartmentName,
			&i.WorkSeconds,
			&i.NormalSeconds,
			&i.FishSeconds,
			&i.IdleSeconds,
			&i.OfflineSeconds,
			&i.AttendanceSeconds,
			&i.EffectiveSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
