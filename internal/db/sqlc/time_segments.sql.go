// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: time_segments.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countNonOfflineSegmentsOverlap = `-- name: CountNonOfflineSegmentsOverlap :one
SELECT COUNT(1)
FROM time_segments
WHERE employee_id = ?
  AND status != 'offline'
  AND start_at < ?
  AND end_at > ?
`

type CountNonOfflineSegmentsOverlapParams struct {
	EmployeeID int64     `json:"employee_id"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
}

func (q *Queries) CountNonOfflineSegmentsOverlap(ctx context.Context, arg CountNonOfflineSegmentsOverlapParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNonOfflineSegmentsOverlap, arg.EmployeeID, arg.StartAt, arg.EndAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOfflineSegmentsCover = `-- name: CountOfflineSegmentsCover :one
SELECT COUNT(1)
FROM time_segments
WHERE employee_id = ?
  AND status = 'offline'
  AND start_at <= ?
  AND end_at >= ?
`

type CountOfflineSegmentsCoverParams struct {
	EmployeeID int64     `json:"employee_id"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
}

func (q *Queries) CountOfflineSegmentsCover(ctx context.Context, arg CountOfflineSegmentsCoverParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOfflineSegmentsCover, arg.EmployeeID, arg.StartAt, arg.EndAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTimeSegment = `-- name: CreateTimeSegment :exec
INSERT INTO time_segments (
  employee_id,
  start_at,
  end_at,
  status,
  description,
  source
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateTimeSegmentParams struct {
	EmployeeID  int64              `json:"employee_id"`
	StartAt     time.Time          `json:"start_at"`
	EndAt       time.Time          `json:"end_at"`
	Status      TimeSegmentsStatus `json:"status"`
	Description sql.NullString     `json:"description"`
	Source      TimeSegmentsSource `json:"source"`
}

func (q *Queries) CreateTimeSegment(ctx context.Context, arg CreateTimeSegmentParams) error {
	_, err := q.db.ExecContext(ctx, createTimeSegment,
		arg.EmployeeID,
		arg.StartAt,
		arg.EndAt,
		arg.Status,
		arg.Description,
		arg.Source,
	)
	return err
}

const deleteManualSegment = `-- name: DeleteManualSegment :exec
DELETE FROM time_segments
WHERE employee_id = ?
  AND source = 'manual'
  AND start_at = ?
  AND end_at = ?
`

type DeleteManualSegmentParams struct {
	EmployeeID int64     `json:"employee_id"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
}

func (q *Queries) DeleteManualSegment(ctx context.Context, arg DeleteManualSegmentParams) error {
	_, err := q.db.ExecContext(ctx, deleteManualSegment, arg.EmployeeID, arg.StartAt, arg.EndAt)
	return err
}

const listOfflineSegmentsByDate = `-- name: ListOfflineSegmentsByDate :many
SELECT ts.employee_id,
       e.employee_code,
       e.name,
       d.name AS department_name,
       ts.start_at,
       ts.end_at
FROM time_segments ts
JOIN employees e ON ts.employee_id = e.id
LEFT JOIN departments d ON e.department_id = d.id
WHERE ts.status = 'offline'
  AND ts.start_at < ?
  AND ts.end_at > ?
ORDER BY ts.start_at
`

type ListOfflineSegmentsByDateParams struct {
	StartAt time.Time `json:"start_at"`
	EndAt   time.Time `json:"end_at"`
}

type ListOfflineSegmentsByDateRow struct {
	EmployeeID     int64          `json:"employee_id"`
	EmployeeCode   string         `json:"employee_code"`
	Name           string         `json:"name"`
	DepartmentName sql.NullString `json:"department_name"`
	StartAt        time.Time      `json:"start_at"`
	EndAt          time.Time      `json:"end_at"`
}

func (q *Queries) ListOfflineSegmentsByDate(ctx context.Context, arg ListOfflineSegmentsByDateParams) ([]ListOfflineSegmentsByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, listOfflineSegmentsByDate, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOfflineSegmentsByDateRow
	for rows.Next() {
		var i ListOfflineSegmentsByDateRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.EmployeeCode,
			&i.Name,
			&i.DepartmentName,
			&i.StartAt,
			&i.EndAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOfflineSegmentsByEmployeeAndRange = `-- name: ListOfflineSegmentsByEmployeeAndRange :many
SELECT id, employee_id, start_at, end_at, status, description, source
FROM time_segments
WHERE employee_id = ?
  AND status = 'offline'
  AND start_at < ?
  AND end_at > ?
ORDER BY start_at
`

type ListOfflineSegmentsByEmployeeAndRangeParams struct {
	EmployeeID int64     `json:"employee_id"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
}

type ListOfflineSegmentsByEmployeeAndRangeRow struct {
	ID          int64              `json:"id"`
	EmployeeID  int64              `json:"employee_id"`
	StartAt     time.Time          `json:"start_at"`
	EndAt       time.Time          `json:"end_at"`
	Status      TimeSegmentsStatus `json:"status"`
	Description sql.NullString     `json:"description"`
	Source      TimeSegmentsSource `json:"source"`
}

func (q *Queries) ListOfflineSegmentsByEmployeeAndRange(ctx context.Context, arg ListOfflineSegmentsByEmployeeAndRangeParams) ([]ListOfflineSegmentsByEmployeeAndRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listOfflineSegmentsByEmployeeAndRange, arg.EmployeeID, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOfflineSegmentsByEmployeeAndRangeRow
	for rows.Next() {
		var i ListOfflineSegmentsByEmployeeAndRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.StartAt,
			&i.EndAt,
			&i.Status,
			&i.Description,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimeSegmentsByEmployeeAndRange = `-- name: ListTimeSegmentsByEmployeeAndRange :many
SELECT id, employee_id, start_at, end_at, status, description, source
FROM time_segments
WHERE employee_id = ?
  AND start_at < ?
  AND end_at > ?
ORDER BY start_at
`

type ListTimeSegmentsByEmployeeAndRangeParams struct {
	EmployeeID int64     `json:"employee_id"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
}

type ListTimeSegmentsByEmployeeAndRangeRow struct {
	ID          int64              `json:"id"`
	EmployeeID  int64              `json:"employee_id"`
	StartAt     time.Time          `json:"start_at"`
	EndAt       time.Time          `json:"end_at"`
	Status      TimeSegmentsStatus `json:"status"`
	Description sql.NullString     `json:"description"`
	Source      TimeSegmentsSource `json:"source"`
}

func (q *Queries) ListTimeSegmentsByEmployeeAndRange(ctx context.Context, arg ListTimeSegmentsByEmployeeAndRangeParams) ([]ListTimeSegmentsByEmployeeAndRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listTimeSegmentsByEmployeeAndRange, arg.EmployeeID, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTimeSegmentsByEmployeeAndRangeRow
	for rows.Next() {
		var i ListTimeSegmentsByEmployeeAndRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.StartAt,
			&i.EndAt,
			&i.Status,
			&i.Description,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateManualSegment = `-- name: UpdateManualSegment :exec
UPDATE time_segments
SET start_at = ?, end_at = ?, description = ?
WHERE employee_id = ?
  AND source = 'manual'
  AND start_at = ?
  AND end_at = ?
`

type UpdateManualSegmentParams struct {
	StartAt     time.Time      `json:"start_at"`
	EndAt       time.Time      `json:"end_at"`
	Description sql.NullString `json:"description"`
	EmployeeID  int64          `json:"employee_id"`
	StartAt_2   time.Time      `json:"start_at_2"`
	EndAt_2     time.Time      `json:"end_at_2"`
}

func (q *Queries) UpdateManualSegment(ctx context.Context, arg UpdateManualSegmentParams) error {
	_, err := q.db.ExecContext(ctx, updateManualSegment,
		arg.StartAt,
		arg.EndAt,
		arg.Description,
		arg.EmployeeID,
		arg.StartAt_2,
		arg.EndAt_2,
	)
	return err
}
